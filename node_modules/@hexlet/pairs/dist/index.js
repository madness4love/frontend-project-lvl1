"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toString = exports.cdr = exports.car = exports.checkPair = exports.isPair = exports.cons = void 0;

// @ts-check

/**
 * Build pair
 * @example
 * const pair = cons(5, 'hello');
 * @example
 * const pair = cons(cons(1, null), 'world');
 */
const cons = (a, b) => {
  const pair = message => {
    switch (message) {
      case 'car':
        return a;

      case 'cdr':
        return b;

      default:
        throw new Error(`Unknown message '${message}'`);
    }
  };

  pair.pair = true;
  return pair;
};
/**
 * Check if something is pair
 * @example
 * const pair = cons(5, 'hello');
 * isPair(pair); // true
 * isPair(5); // false
 */


exports.cons = cons;

const isPair = pair => typeof pair === 'function' && pair.pair;

exports.isPair = isPair;

const checkPair = pair => {
  if (!isPair(pair)) {
    const value = typeof pair === 'object' ? JSON.stringify(pair, null, 2) : String(pair);
    throw new Error(`Argument must be pair, but it was '${value}'`);
  }
};
/**
 * Get car (first element) from pair
 * @example
 * const pair = cons(5, 'hello');
 * car(pair); // 5
 */


exports.checkPair = checkPair;

const car = pair => {
  checkPair(pair);
  return pair('car');
};
/**
 * Get cdr (second element) from pair
 * @example
 * const pair = cons(5, 'hello');
 * cdr(pair); // hello
 */


exports.car = car;

const cdr = pair => {
  checkPair(pair);
  return pair('cdr');
};
/**
 * Convert pair to string (recursively)
 * @example
 * toString(cons('', 10)); // ('', 10)
 */


exports.cdr = cdr;

const toString = pair => {
  checkPair(pair);

  const rec = p => {
    if (!isPair(p)) {
      return String(p);
    }

    const left = car(p);
    const right = cdr(p);
    return `(${rec(left)}, ${rec(right)})`;
  };

  return rec(pair);
};

exports.toString = toString;

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBRUE7Ozs7Ozs7QUFPTyxNQUFNLElBQUksR0FBRyxDQUFDLENBQUQsRUFBSSxDQUFKLEtBQVU7QUFDNUIsUUFBTSxJQUFJLEdBQUksT0FBRCxJQUFhO0FBQ3hCLFlBQVEsT0FBUjtBQUNFLFdBQUssS0FBTDtBQUNFLGVBQU8sQ0FBUDs7QUFDRixXQUFLLEtBQUw7QUFDRSxlQUFPLENBQVA7O0FBQ0Y7QUFDRSxjQUFNLElBQUksS0FBSixDQUFXLG9CQUFtQixPQUFRLEdBQXRDLENBQU47QUFOSjtBQVFELEdBVEQ7O0FBVUEsRUFBQSxJQUFJLENBQUMsSUFBTCxHQUFZLElBQVo7QUFDQSxTQUFPLElBQVA7QUFDRCxDQWJNO0FBZVA7Ozs7Ozs7Ozs7O0FBT08sTUFBTSxNQUFNLEdBQUksSUFBRCxJQUFVLE9BQU8sSUFBUCxLQUFnQixVQUFoQixJQUE4QixJQUFJLENBQUMsSUFBNUQ7Ozs7QUFFQSxNQUFNLFNBQVMsR0FBSSxJQUFELElBQVU7QUFDakMsTUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFELENBQVgsRUFBbUI7QUFDakIsVUFBTSxLQUFLLEdBQUcsT0FBTyxJQUFQLEtBQWdCLFFBQWhCLEdBQTJCLElBQUksQ0FBQyxTQUFMLENBQWUsSUFBZixFQUFxQixJQUFyQixFQUEyQixDQUEzQixDQUEzQixHQUEyRCxNQUFNLENBQUMsSUFBRCxDQUEvRTtBQUNBLFVBQU0sSUFBSSxLQUFKLENBQVcsc0NBQXFDLEtBQU0sR0FBdEQsQ0FBTjtBQUNEO0FBQ0YsQ0FMTTtBQU9QOzs7Ozs7Ozs7O0FBTU8sTUFBTSxHQUFHLEdBQUksSUFBRCxJQUFVO0FBQzNCLEVBQUEsU0FBUyxDQUFDLElBQUQsQ0FBVDtBQUNBLFNBQU8sSUFBSSxDQUFDLEtBQUQsQ0FBWDtBQUNELENBSE07QUFLUDs7Ozs7Ozs7OztBQU1PLE1BQU0sR0FBRyxHQUFJLElBQUQsSUFBVTtBQUMzQixFQUFBLFNBQVMsQ0FBQyxJQUFELENBQVQ7QUFDQSxTQUFPLElBQUksQ0FBQyxLQUFELENBQVg7QUFDRCxDQUhNO0FBS1A7Ozs7Ozs7OztBQUtPLE1BQU0sUUFBUSxHQUFJLElBQUQsSUFBVTtBQUNoQyxFQUFBLFNBQVMsQ0FBQyxJQUFELENBQVQ7O0FBQ0EsUUFBTSxHQUFHLEdBQUksQ0FBRCxJQUFPO0FBQ2pCLFFBQUksQ0FBQyxNQUFNLENBQUMsQ0FBRCxDQUFYLEVBQWdCO0FBQ2QsYUFBTyxNQUFNLENBQUMsQ0FBRCxDQUFiO0FBQ0Q7O0FBQ0QsVUFBTSxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUQsQ0FBaEI7QUFDQSxVQUFNLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBRCxDQUFqQjtBQUNBLFdBQVEsSUFBRyxHQUFHLENBQUMsSUFBRCxDQUFPLEtBQUksR0FBRyxDQUFDLEtBQUQsQ0FBUSxHQUFwQztBQUNELEdBUEQ7O0FBU0EsU0FBTyxHQUFHLENBQUMsSUFBRCxDQUFWO0FBQ0QsQ0FaTSIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEJ1aWxkIHBhaXJcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBwYWlyID0gY29ucyg1LCAnaGVsbG8nKTtcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBwYWlyID0gY29ucyhjb25zKDEsIG51bGwpLCAnd29ybGQnKTtcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnMgPSAoYSwgYikgPT4ge1xuICBjb25zdCBwYWlyID0gKG1lc3NhZ2UpID0+IHtcbiAgICBzd2l0Y2ggKG1lc3NhZ2UpIHtcbiAgICAgIGNhc2UgJ2Nhcic6XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgY2FzZSAnY2RyJzpcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbWVzc2FnZSAnJHttZXNzYWdlfSdgKTtcbiAgICB9XG4gIH07XG4gIHBhaXIucGFpciA9IHRydWU7XG4gIHJldHVybiBwYWlyO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBzb21ldGhpbmcgaXMgcGFpclxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHBhaXIgPSBjb25zKDUsICdoZWxsbycpO1xuICogaXNQYWlyKHBhaXIpOyAvLyB0cnVlXG4gKiBpc1BhaXIoNSk7IC8vIGZhbHNlXG4gKi9cbmV4cG9ydCBjb25zdCBpc1BhaXIgPSAocGFpcikgPT4gdHlwZW9mIHBhaXIgPT09ICdmdW5jdGlvbicgJiYgcGFpci5wYWlyO1xuXG5leHBvcnQgY29uc3QgY2hlY2tQYWlyID0gKHBhaXIpID0+IHtcbiAgaWYgKCFpc1BhaXIocGFpcikpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHR5cGVvZiBwYWlyID09PSAnb2JqZWN0JyA/IEpTT04uc3RyaW5naWZ5KHBhaXIsIG51bGwsIDIpIDogU3RyaW5nKHBhaXIpO1xuICAgIHRocm93IG5ldyBFcnJvcihgQXJndW1lbnQgbXVzdCBiZSBwYWlyLCBidXQgaXQgd2FzICcke3ZhbHVlfSdgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgY2FyIChmaXJzdCBlbGVtZW50KSBmcm9tIHBhaXJcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBwYWlyID0gY29ucyg1LCAnaGVsbG8nKTtcbiAqIGNhcihwYWlyKTsgLy8gNVxuICovXG5leHBvcnQgY29uc3QgY2FyID0gKHBhaXIpID0+IHtcbiAgY2hlY2tQYWlyKHBhaXIpO1xuICByZXR1cm4gcGFpcignY2FyJyk7XG59O1xuXG4vKipcbiAqIEdldCBjZHIgKHNlY29uZCBlbGVtZW50KSBmcm9tIHBhaXJcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBwYWlyID0gY29ucyg1LCAnaGVsbG8nKTtcbiAqIGNkcihwYWlyKTsgLy8gaGVsbG9cbiAqL1xuZXhwb3J0IGNvbnN0IGNkciA9IChwYWlyKSA9PiB7XG4gIGNoZWNrUGFpcihwYWlyKTtcbiAgcmV0dXJuIHBhaXIoJ2NkcicpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHBhaXIgdG8gc3RyaW5nIChyZWN1cnNpdmVseSlcbiAqIEBleGFtcGxlXG4gKiB0b1N0cmluZyhjb25zKCcnLCAxMCkpOyAvLyAoJycsIDEwKVxuICovXG5leHBvcnQgY29uc3QgdG9TdHJpbmcgPSAocGFpcikgPT4ge1xuICBjaGVja1BhaXIocGFpcik7XG4gIGNvbnN0IHJlYyA9IChwKSA9PiB7XG4gICAgaWYgKCFpc1BhaXIocCkpIHtcbiAgICAgIHJldHVybiBTdHJpbmcocCk7XG4gICAgfVxuICAgIGNvbnN0IGxlZnQgPSBjYXIocCk7XG4gICAgY29uc3QgcmlnaHQgPSBjZHIocCk7XG4gICAgcmV0dXJuIGAoJHtyZWMobGVmdCl9LCAke3JlYyhyaWdodCl9KWA7XG4gIH07XG5cbiAgcmV0dXJuIHJlYyhwYWlyKTtcbn07XG4iXX0=